이제까지 일반적으로 numpy 배열의 연산은 아주 빠르거나 느리게 수행될 수 있습니다.
연산을 빠르게 수행시키는 방법 중에 하나는 벡터화(vectorized) 연산을 사용한 것입니다.
이러한 목적으로 제공하는 것이 numpy에서 유니버설 함수(universal function)입니다.
numpy 유니버설 함수는 몇 개의 배열에 대해서 적용되는지에 따라서 단항(unary) 유니버설 함수와 이항(binary) 유니버설 함수로 구분이 됩니다.
단항 유니버설 함수에 대한 예제를 몇 가지를 살펴보겠습니다.
배열 산술 연산은 파이썬의 기본 산술 연산자를 그대로 사용하는 것이므로 흔히 사용되는 연산입니다. 덧셈, 뺄셈, 곱셈, 나눗셈 모두 사용 가능한데요.
화면에서 보는 코드와 같습니다. 유의할 사항으로, 마지막 부분의 네모상자로 표시된 정수 나눗셈 연산은
나머지를 버린 몫으로만 결과가 산출됩니다. 그래서 정숫값의 결과가 나옵니다.
또한, 다른 단항 유니버설 함수로서 음수, 지수, 나머지 연산자의 예를 살펴보겠습니다.
numpy는 연산의 편의를 위해 각 산술 연산자마다 이에 대응하는 래퍼 함수(wrapper function)를 제공합니다.
예를 들어, add 함수는 + 연산자에 대한 래퍼 함수를 나타냅니다.
화면의 표는 산술연산자와 이에 대응하는 numpy 래퍼 함수를 보여줍니다.
파이썬의 절댓값 함수인 abs 함수와 마찬가지로 numpy에서도 절댓값 함수로 화면의 코드에서 볼 수 있듯이 absolute 혹은 줄여서 abs 함수를 제공합니다.
이 절댓값 함수는 복소수 데이터에도 적용이 됩니다.
다음 화면의 코드와 같이 복소수의 절댓값으로 복소수의 크기를 반환합니다.
파이썬은 수많은 유니버설 함수를 제공하고 있으며, 빅데이터 분석 처리에 가장 유용하게 사용되는 함수 중에 하나가 삼각 함수입니다.
먼저 삼각 함수에 적용할 각도 배열을 정의하고, 그런 다음 삼각 함수 sin, cos, tan에 연속해서 적용해 보겠습니다.
아울러, 역삼각 함수도 numpy에서 제공합니다.
화면의 코드와 같습니다.
numpy 유니버설 함수로 제공되는 보편적인 유형의 함수로 지수 함수가 있습니다.
화면의 코드는 다양한 지수 연산에 대한 함수를 보여줍니다.
지수 함수의 역인 로그 함수도 numpy에서 제공합니다.
기본 log는 자연로그를 나타내면, 2를 밑으로 하는 log나 10을 밑으로 하는 log를 계산하는 것도 가능합니다.
다음으로 단순 기능을 보다는 특화된 기능을 사용하는 유니버설 함수에 대해서 살펴보겠습니다.
화면의 코드는 연산 결과를 위한 임시 배열을 생성하지 않고 지정한 배열에 직접 연산 결과를 쓸 수 있도록 하는 예입니다.
모든 유니버설 함수에 out 인자를 사용하면 그 결과를 직접 출력할 수 있습니다.
연산 결과를 지정된 배열의 요소에 하나씩 건너뛰면서 쓸 수도 있습니다.
이 예제에서는 y에 연산 결과를 지정하여 저장하지만, 배열 슬라이싱을 사용하여 2씩 건너뛰면서 저장하였습니다.
일반적으로, out 인자에 저장할 변수를 지정하여 연산결과를 직접 쓰는 것은 소규모 연산에서는 연산 시간 측면에서 아주 큰 절감이 없습니다.
그러나, 대규모 연산의 경우에는 그 연산 결과를 임시로 지정할 배열이 생략됨으로써
메모리 절약이 상당히 크며 이로 인하여 연산 시간의 절감에 또한 도움이 됩니다.
다음으로 numpy에서 제공하는 몇 가지 집계 함수에 대해서 살펴보겠습니다.
배열을 특정 연산으로 축소하고자 한다면, reduce 함수를 사용할 수 있습니다.
reduce 함수는 결과가 하나만 남을 때까지 해당 연산을 배열 요소에 반복하여 적용합니다.
다음 화면의 예는 sum 함수로서 배열 내의 모든 값들의 합계를 구하는 것입니다.
또한 numpy에서는 배열 내에서 최솟값과 최댓값을 찾아주는 min, max 함수를 제공합니다.
다음 화면의 예는 numpy의 min과 max 함수의 적용 예를 보여줍니다.
집계 연산은 1차원 배열뿐만 아니라 다차원 배열에도 적용이 됩니다.
집계 연산의 일반적인 유형은 행이나 열을 기준으로 집계를 하는 것입니다.
집계 연산은 어느 축을 따라 집계할지를 지정하는 추가적인 인자인 axis에 값을 지정하여 축에 따라 집계 결과를 얻을 수 있습니다.
화면의 그림에서 같이, 집계 함수에 axis 인자의 값을 0으로 지정하면, 열을 기준으로 집계 연산이 수행됩니다.
만일 axis 인자의 값을 1로 지정하면, 행을 기준으로 집계 연산이 수행됩니다.
그리고 아무것도 지정하지 않으면, 즉, axis 인자를 사용하지 않으면, 배열 내의 모든 요소를 대상으로 집계 연산을 수행하게 됩니다.
화면의 코드와 같이 2차원 배열이 있다고 가정해 봅시다.
다음과 같이 sum 함수를 사용하였고 axis 지정이 없으면, 전체 배열의 집계 을 구해져서, 요소의 총합을 산출하게 됩니다.
한편, 각 열의 최댓값을 찾을려면, 화면의 코드와 같이 axis를 0으로 지정하면 그 값을 얻을 수 있습니다.
이 함수는 네 개의 열마다 최댓값을 각각 구하여 총 네 개 값을 반환합니다.
그리고 다음 화면의 예제에서는 axis의 지정을 1로 하여 행 별로 가장 큰 값을 얻어내어 총 3개의 값이 반환되게 됩니다.
이 밖에도 numpy에는 많은 수의 집계 함수가 있습니다.
이러한 함수들 모두를 자세히 다루기엔 너무나 많기 때문에, 화면과 같이 유용하게 사용될 수 집계 함수를 표로서 나열하였습니다.
이러한 집계 함수들의 이름을 면밀히 살펴보면 그 의미를 충분히 파악할 수 있는데요.
예를 들어, prod 함수는 product의 약자로 요소 값들의 곱이라는 의미를 단어를 보고 쉽게 유추할 수 있습니다.
이러한 집계 함수들을 본 교과목의 나머지 주차에서 종종 사용할 것입니다.
이제까지 느린 수행을 제거하고자 연산을 벡터화하는 numpy의 유니버설 함수에 대해서 살펴보았습니다.
벡터화 연산의 또 다른 방법으로 numpy의 브로드캐스팅 기능이 있습니다.
브로드캐스팅은 서로 다른 크기의 배열에 이항 유니버설 함수를 적용할 수 있는 기능을 제공합니다.
원래 파이썬에서는 서로 다른 차원의 리스트끼리 연산을 수행하려면 for 루프를 사용하여 각 반복마다 요솟값끼리 잘 대조하여 연산을 수행해야 합니다.
그러나 numpy에서는 단순히 연산을 적용하기만 됩니다.
이렇게 되는 이유는 바로 브로드캐스팅 기능이 있기 때문입니다.
그럼, 브로드캐스팅 연산에 대해서 자세히 살펴보겠습니다.
먼저 같은 크기의 배열로 이항 연산을 수행하는 예를 살펴보겠습니다.
화면의 예는 2개의 배열 x와 y를 서로 더하는 연산을 보여주고 있습니다.
이 두 개의 배열은 서로 크기가 같기 때문에 덧셈 연산을 수행하는 데 있어서 의심할 여지 없이 아무 문제 없습니다.
결과 또한 예상하던 결과로 나옵니다.
그러나 이항 연산에 서로 다른 크기의 배열을 적용하면 어떻게 연산이 되는지 궁금하게 됩니다.
그런데 이런 경우에는 numpy의 브로드캐스팅 기능에 의해서 결과를 얻을 수 있습니다.
화면의 예처럼 배열에 스칼라값을 더하는 것을 한번 살펴보겠습니다.
이 예제는 값 10을 배열의 각 요소에 단순히 더하는 연산이라고 할 수 있습니다.
아니면, 배열 x를 10만큼 확장한다고 생각할 수도 있습니다.
기하학적 그림으로 살펴보면, 화면의 그림과 같으며, 투명하게 보이는 박스는 브로드캐스팅된 값을 나타냅니다.
다시 말해서, 이 부가적 메모리는 연산 과정에서 실제로 할당되지는 않지만, 개념적으로 상상하여 이해하는 데 도움이 됩니다.
즉, 10이라는 스칼라 값이지만, 브로드캐스팅되어 1차원 배열로 확장되고,
이것이 덧셈의 두 번째 피연산자로 활용되어 같은 크기의 배열로서 덧셈이 무리 없이 수행되는 것입니다.
브로드캐스팅 기능은 배열을 더 높은 차원으로 확장할 수 있고, 2개 배열의 차원이 서로 설사 다르더라도 배열을 확장해 주는 기능입니다.
그런데 무작정 확장하는 것이 아니라 브로드캐스팅을 적용할 때 배열 확장의 일관성 유지를 위해 다음과 같이 3가지 규칙이 있습니다.
첫 번째 규칙은 두 배열의 차원 수가 서로 다르면, 더 작은 차원을 가진 배열의 앞(왼쪽 부분)을 1로 채워줍니다.
두 번째 규칙은 두 배열의 형상이 어떤 차원에서도 일치하지 않으면, 해당 차원의 형상이 1인 배열이 늘어납니다.
세 번째 규칙은 임의의 차원에서 크기가 일치하지 않고 1도 아니라면, 오류가 발생합니다.
다음 화면의 예는 1차원 배열에 2차원 배열을 더하는 예를 보여줍니다.
이 예제는 1차원 배열 x가 2차원 배열 M의 형상에 맞추기 위해 1차원에서 2차원으로 확장 또는 브로드캐스팅되는 것을 보여줍니다.
기하학적 그림으로 살펴보면, 화면의 그림과 같으며, 투명하게 보이는 박스는 브로드캐스팅된 값을 나타냅니다.
앞서 살펴본 브로드캐스팅의 두 번째에 해당하는 규칙이 적용된 예입니다.
이번에는 두 배열 모두 브로드캐스팅이 필요한 예제를 살펴보겠습니다.
이 예제는 앞서 살펴본 브로드캐스팅 규칙 2에 따라 각 차원을 다른 배열의 크기에 일치하도록 늘리는 것입니다.
그런 다음, 두 배열을 대상으로 덧셈을 수행하는 것입니다.
화면의 그림과 같이 기하학적 그림을 살펴보면, a 배열은 3×1 크기의 배열이고 b 배열은 1×3 크기의 배열입니다.
그래서 두 배열의 형상이 서로 일치하지 않는데요.
이 경우에는 상대방 배열의 크기에 맞추어 서로 브로드캐스팅하여 가상적으로 두 배열 모두 3×3 행렬로 일치시킨 상태에서 덧셈 연산을 수행하는 것입니다.
브로드캐스팅은 2차원 함수를 기반으로 이미지를 그릴 때도 매우 유용하게 사용되고 있습니다.
화면의 코드에서 x와 y는 0에서 5까지 50단계로 나눈 배열을 의미합니다.
2차열 배열을 플로팅하기 위해, matplotlib을 사용합니다.
matplotlib에 대해서는 5주차에 자세히 다룰 것입니다.
이 예제에서는 2차원 배열의 시각화 예를 보여주는 것이므로 matplotlib에 대한 설명은 생략하겠습니다.
화면의 코드를 colab에 입력하면, 2차원 배열을 강렬한 색상으로 시각화하여 화면과 같은 그래프가 그려집니다.
이제까지는 단순히 수행 속도를 빠르게 해주는 numpy의 기능에 대해서 알아보았습니다.
지금부터는 배열에서 요소 단위의 비교 기능을 활용하여 연산 시간을 감소시킬 수 있는 방법에 대해서 살펴보겠습니다.
다음 화면의 예는 행렬의 데이터 전부 혹은 일부가 조건에 만족하는 지의 여부를 결과로 산출하는 예입니다.
이 예제에서 np.any 함수는 하나라도 만족하면 true를 산출합니다.
즉, or 논리 연산자의 결과와 같습니다.
결과로 True, False가 나오는데, 5보다 작은 값은 하나가 있기 때문에 True가 나왔습니다.
그리고 0보다 작은 요솟값은 없기 때문에 False가 산출됩니다.
반면, 화면의 다음 예제에서의 np.all 함수는 모두 만족해야 True를 산출합니다.
이 함수의 결과는 and 논리 연산자의 결과와 같습니다. 결과로 False, True가 산출되는데요.
5보다 큰 요소값은 모두가 아니므로 False 값이 산출되며, 10보다 작은 요소값은 모두가 만족하기때문에 True로 산출됩니다.
이러한 비교 연산자와 이와 대응하는 유니버설 함수를 정리하면 화면의 표와 같습니다.
산술 유니버설 함수와 마찬가지로, 비교 연산자와 비교 유니버설 함수 또한 모든 크기와 형상의 배열에 적용됩니다.
먼저, 1차원 배열 2개를 활용하는 예제로 다음 화면의 코드를 살펴보도록 하겠습니다.
두 개의 배열 a와 b는 각각 1과 5사이의 구간에서 5개의 정수를 무작위로 발생시켜 구성한 1차원 배열을 나타냅니다.
이 두 배열이 같은지에 대한 연산은 두 배열의 각각의 요소를 비교해서 이에 해당하는 불리언값을 산출합니다.
화면과 같이 두 배열이 같은지에 대해서 불리언값을 가진 배열이 결과로 산출되었습니다.
화면의 코드는 2차원 배열에 적용한 예제를 보여줍니다.
이 예제의 결과는 화면에서 볼 수 있듯이 요솟값이 True 혹은 False인 2차원 불리언 배열로 산출됩니다.
한편, numpy에서는 특정 조건에 따른 값을 배열 형태로 추출할 수 있는 기능을 가지고 있습니다.
바로 마스크를 사용하여 원본 데이터 자체에서 특정 부분 집합을 선택하여 추출하는 것입니다.
앞서 살펴본 2차원 배열 x에 5보다 작은 값으로 구성된 부분 배열을 구한다고 해봅시다.
그러면 화면의 코드와 같이 작성하면 원하는 결과를 얻을 수 있습니다.
앞서 단순 인덱싱, 슬라이싱, 마스크를 사용하여 배열 일부에 접근하고 요솟값을 수정하는 방법에 대해서 살펴보았습니다.
이번에는 좀 더 기능이 강화된 팬시 인덱싱(fancy indexing)이라는 것을 살펴보도록 하겠습니다.
펜시 인덱싱은 단순 인덱싱 방법과 비슷하지만 단순 인덱스 값을 사용하는 것이 아니라,
인덱스 배열을 전달하여 인덱스 배열의 값을 인덱스로 사용하는 방법입니다.
이렇게 함으로서 복잡한 배열값의 하위 집합에 매우 빠르게 접근해 값을 수정할 수 있다는 장점이 있습니다.
즉, 인덱스 배열의 값을 인덱스로 사용하여 배열의 요솟값에 접근하는 방법입니다.
화면의 코드를 예로써 살펴보도록 하겠습니다.
배열 b가 인덱스 배열로 사용되어 배열 a에서 하위 배열을 추출한 예를 보여줍니다.
즉, 배열 a에서 인덱스 3, 6, 9에 해당하는 요솟값을 추출하여 그것으로 배열을 구성한 예입니다.
한편, 팬시 인덱싱은 2차원 이상의 다차원에서도 동작이 가능합니다.
화면의 코드를 살펴보겠습니다.
표준 인덱싱을 사용할 때와 마찬가지로 2차원 배열에 첫 번째 인덱스는 행 배열 형태로,
두 번째 인덱스는 열 배열 형태로 전달하면, 화면과 같은 결과가 산출됩니다.
결과의 첫 번째 값은 x[0, 2]의 값이 해당되며, 두 번째 값은 x[1, 1]의 값이 해당됩니다.
세 번째 값은 x[2, 3]의 값이 해당됩니다.
